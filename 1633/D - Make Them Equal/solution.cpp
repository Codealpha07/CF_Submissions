// author : CodeAlpha07 #include <bits/stdc++.h>using namespace std;//------------------------------------------------------------------------------------------------------------------------------------#define ll long long#define ull unsigned long long#define lld long double#define pii pair<int, int>#define pll pair<ll, ll>#define vi vector<int>#define vl vector<ll>#define vvi vector<vector<int>>#define vvl vector<vector<ll>>#define vpi vector<pii>#define vpl vector<pll>#define vin(a) for (int i = 0; i < (a).size(); ++i) cin >> a[i];#define vout(a) for (int i = 0; i < (a).size(); ++i) cout << a[i] << ' ';#define all(a) a.begin(), a.end()#define rall(a) a.rbegin(), a.rend()#define mii map<int, int>#define mci map<char, int>#define si set<int>#define sc set<char>#define sl set<ll>#define prql(a) priority_queue<a>#define prqs(a) priority_queue<a,vector<a>,greater<a>>#define pb push_back#define eb emplace_back#define ff first#define ss second#define sqrt(x) sqrtl(x)#define endl "\n"#define yes cout << "Yes" << endl;#define no cout << "No" << endl;#define M 1000000007#define M1 998244353#define fo(i,a,b) for(int i=(int)a;i<(int)b;i++)#define forr(i,a,b) for(int i=(int)a;i>=(int)b;i--)#define PI 3.1415926535897932384626433832795//------------------------------------------------------------------------------------------------------------------------------------#ifndef ONLINE_JUDGE#define debug(x) cerr << #x << " "; _print(x); cerr << endl;#else#define debug(x)#endif void _print(ll t) { cerr << t; }void _print(int t) { cerr << t; }void _print(string t) { cerr << t; }void _print(char t) { cerr << t; }void _print(lld t) { cerr << t; }void _print(double t) { cerr << t; }void _print(ull t) { cerr << t; } template <class T, class V> void _print(pair<T, V> p);template <class T> void _print(vector<T> v);template <class T> void _print(set<T> v);template <class T, class V> void _print(map<T, V> v);template <class T> void _print(multiset<T> v);template <class T, class V> void _print(pair<T, V> p) { cerr << "{"; _print(p.first); cerr << ","; _print(p.second); cerr << "}"; }template <class T> void _print(vector<T> v) { cerr << "[ "; for (T i : v) { _print(i); cerr << ", "; } cerr << "]"; }template <class T> void _print(set<T> v) { cerr << "[ "; for (T i : v) { _print(i); cerr << ", "; } cerr << "]"; }template <class T> void _print(multiset<T> v) { cerr << "[ "; for (T i : v) { _print(i); cerr << ", "; } cerr << "]"; }template <class T, class V> void _print(map<T, V> v) { cerr << "[ "; for (auto i : v) { _print(i); cerr << ", "; } cerr << "]"; }//------------------------------------------------------------------------------------------------------------------------------------ll gcd(ll a, ll b) { if (b == 0) return a; return gcd(b, a % b); }ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }string to_upper(string a) { for (int i = 0; i < (int)a.size(); ++i) if (a[i] >= 'a' && a[i] <= 'z') a[i] -= 'a' - 'A'; return a; }string to_lower(string a) { for (int i = 0; i < (int)a.size(); ++i) if (a[i] >= 'A' && a[i] <= 'Z') a[i] += 'a' - 'A'; return a; }bool prime(ll a) { if (a == 1) return 0; for (int i = 2; i <= round(sqrt(a)); ++i) if (a % i == 0) return 0; return 1; }bool palindrome(string s) { int n = s.length(); for (int i = 0; i < n / 2; i++) if (s[i] != s[n - 1 - i]) return 0; return 1; }ll cacl_mex(vl a){vl hashmap(a.size()+1,0);for(ll i=0;i<a.size();i++){if(a[i]<a.size())hashmap[a[i]]++;}for(ll i=0;i<=a.size();i++){if(hashmap[i]==0){return i;}}return -1;}ll binexp(ll a, ll b, ll p) { ll temp=1; while(b>0) { if (b&1) temp=((temp%p)*(a%p))%p; a=((a%p)*(a%p))%p; b>>=1;} return temp%p; }ll inv(ll x, ll p = M) { return x <= 1 ? x : p - p / x * inv(p % x) % p; }ll countDigit(ll n) { return n / 10 == 0 ? 1 : 1 + countDigit(n / 10); }ll modinv(ll x, ll md) { return binexp(x, md - 2, md);}void unduplicate(vi &vec) { sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); }vector<bool> isPrime;void sieve() {int n=1e6;isPrime.resize(n+1,true);isPrime[0] = isPrime[1] = false;for (int p = 2; p * p <= n; ++p) {if (isPrime[p]) {for (int i = p * p; i <= n; i += p) {isPrime[i] = false;}}}} //------------------------------------------------------------------------------------------------------------------------------------ const int MAXN = 1000;vi ops(MAXN+1, 1e9); // This function precalculates the number of operations that each a[i]=1 requires to reach b[i]void precompute(){    ops[1] = 0;    for (int a=1; a<=MAXN; a++) {        if(ops[a]==1e9) continue;         /*            floor(a/x) has many repeated values.            Instead of looping all x, we compress ranges.            For a given x:            v = a/x is constant for all x in: x ∈ [x, a/v]            So the next x where v changes is: nx = a/v + 1        */        for (int x=1; x<=a; ) {            int v = a/x;            int nx = a/v + 1;            int b = a+v;            if (b <= MAXN) {                ops[b]=min(ops[b], ops[a]+1);            }            x = nx;        }    }} void solve(){    int n, k;    cin>>n>>k;    vpi arr(n); // {b, c}    for(int i=0; i<n; i++) cin>>arr[i].ff;    for(int i=0; i<n; i++) cin>>arr[i].ss;     // first we will calculate the number of operations that each a[i] requires to reach b[i]    for(auto &a:arr){        // cout<<a.ff<<" "<<ops[a.ff]<<endl;        a.ff = ops[a.ff];    }     // now we need to find the best combinations of {op, cost} that proivdes the maximum profit with max k operations    // Basically a knapsack problem (remember not a fractional one ; so greedy fails here :  DP :)    // DP : states -> dp[i][op] -> maximum coins with first i items with op operations     // dp[i][op] = max coins using first i items with op operations     // vvi dp(n+1, vi(k+1, 0));     // for(int i=1; i<=n; i++){    //     int ops = arr[i-1].ff;    //     int coins = arr[i-1].ss;    //     for(int op=0; op<=k; op++){    //         // don't take    //         dp[i][op] = dp[i-1][op];    //         // take if possible    //         if(ops <= op){    //             dp[i][op] = max(dp[i][op], coins+dp[i-1][op-ops]);    //         }    //     }    // }    // cout<<dp[n][k]<<endl;     //  Space optimization :     vi dp(k+1, 0);    for (int i=0; i<n; i++) {        int op = arr[i].ff;    // ops[b[i]]        int coins = arr[i].ss;  // coins        for (int j=k; j>=op; j--) {            dp[j] = max(dp[j], dp[j-op]+coins);        }    }    cout<<dp[k]<<endl; } signed main(){    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);    #ifndef ONLINE_JUDGE    #endif    int T;    cin >> T;    precompute();        while (T--)    {        solve();    }}